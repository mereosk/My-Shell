Execution and Separate Compilation

To πρόγραμμά μου αποτελείται από 3 directories το include, modules και program. Στο φάκελο programs υπάρχει το κύριο πρόγραμμα, mysh.c, το οποίο περιέχει τη main συνάρτηση. Στη συνέχεια στο φάκελο modules υπάρχει το αρχείο parsing.c στο οποίο γίνεται το parse των εντολών του shell μου. Μέσα από το parsing.c καλούνται λειτουργείες οι οποίες φτιάχνουν τη διεπαφή με το shell μου, έτσι τις έχω χωρίσει στο αρχείο bash_interface.c. Αυτό επίσης το έκανα για να μην βγει πολύ εκτενές το parsing.c. Έπειτα στο modules έχω τα αρχεία ADTList.c, ADTMap.c, ADTVector.c. Τα προηγούμενα είναι, αντίστοιχα, υλοποιήσεις λίστας, πίνακα κατακερμα- τισμού καθώς και ένας δυναμικός πίνακας. Να τονίσω ότι οι υλοποιήσεις των προηγούμενων δομών είναι "εμπνευσμένες" από τις δομές του κ.Χατζηκοκολάκη το 2020. Έχουν γίνει φυσικά αρκετές αλλαγές, αλλά εφόσον μπορούσαμε να χρησιμοποιήσουμε STL για τη C++ δεν έφτιαξα από την αρχή δομές. Επίσης να τονίσω ότι είχα ρωτήσει στο μάθημα για αυτό και μου είχατε πει ότι δεν πειράζει αν ήταν μόνο οι δομές. Φυσικά όλες οι αρχικοποιήσεις των συναρτήσεων που βρίσκονται μέσα στα αρχεία που μόλις περιέγραψα βρίσκονται στο φάκελο include σε αντίστοιχα αρχεία .h. Τέλος υπάρχει το Makefile (βρίσκεται εκτός των directory που περιέγραψα) το οποίο με τη χρήση make μεταγλωττίζει το πρόγραμμά μου. Πιο συγκεκριμένα, παρακάτω παραθέτω τα βήματα για την εκτέλεση του προγράμματος.

Βρίσκομαι έξω από τα directories. Δηλαδή με το ls μου εμφανίζονται τα include, modules και program.
Πατάω make και εκτελείται η μεταγλώττιση του προγράμματος
Πατάω ./program/mysh και εκτελείται το mysh
Να προσθέσω ότι υπάρχει δυνατότητα make run, που μεταγλωττίζει και εκτελεί το πρόγραμμα απευθείας καθώς και make valgrind που καλεί τον debugger αλλά υπάρχει το θέμα ότι δεν γίνειται block το σήμα SIGTSTP λόγω ιδιομορφίας του Makefile. Άρα δεν θα πρό- τεινα να το εκτελέσετε έτσι.

Parsing

Το parsing αποφάσισα να το υλοποιήσω με την τεχνική του state machine. Δηλαδή κάθε χαρα- τήρας του command αλλάζει το state. Να αναφέρω εδώ ότι αρχικά η εντολή σπάει σε υποεντολές, μέσω της strtok, όποτε βρίσκει το ελληνικό ερωτηματικό, έτσι όποτε αναφέρω εντολή εννοώ τις υποεντολές. Έτσι λοιπόν, έχουμε 4 state

Tο EXPCOMMAND(expect command) είναι όταν περιμένουμε κάποιο command (ls, sort, ./signal κλπ) και το συναντάμε στην αρχή αλλά και μετά από pipes (|).
Το ΕΧPARGUMENT(expect argument) είναι όταν περιμένουμε κάποιο argument. Το συναντάμε έπειτα από εντολές.
To OUTREDIRECT είναι όταν βρίσκει το > που σημαίνει ότι θα γίνει output redirection (ls > outputfile). Το shell υποστηρίζει επίσης κάτι του τύπου (ls>outputfile1>outputfile2) το οποίο όπως το bash απλά ανοίγει το ouputfile1 και τα δεδομένα πάνε στο outputfile2. Επίσης όταν συ- ναντήσει το >> αλλάζει το flag appendFlag σε true, το οποίο όταν θα γίνει execute το command θα κάνει append τα δεδομένα στο αρχείο.
Το INREDIRECT είναι όταν βρίσκει το < που σημαίνει ότι θα γίνει input redirection και έχει και αυτό τις παραπάνω ιδιότητες όπως το output redirect με τα παραπάνω σε αριθμό input redi- rections με τη μόνη διαφορά ότι τα αρχεία πρέπει να υπάρχουν.
Όταν συναντήσει το '/0' (ή το & που θα μιλήσω παρακάνω), ανάλογα με το state θα εκτελέσει τη συνάρτηση execute_command την οποία θα εξηγήσω πιο διεξοδικά καθώς είναι και η πιο σημαντι- κή. Οι υπόλοιπες συναρτήσεις που χρησιμοποιούνται έχουν αρκετά σχόλια τα οποία τις εξηγούν καλά.

Execute command function

Στην execute_command περνάω τη λίστα με τις εντολές που έχουν γίνει parse, τη λίστα με τις λί- στες με τα arguments της κάθε εντολής, το input αρχείο που πρέπει να γίνει redirect όπως και το αντίστοιχο output αρχείο, αυτά φυσικά αν υπάρχουν. Επίσης περνάω και δύο flags, το appendFlag το οποίο εξήγησα και παραπάνω αλλά και το backgroundFlag το οποίο υποδεικνύει ότι το command πρέπει να εκτελεστεί στο background. Στη συνέχεια, ανοίγει αν υπάρχουν, κατάλληλα τα input και output αρχεία, τσεκάροντας αν έχουν wild character τους οποίους διαχειρίζεται κατάλληλα. Στη συνέχεια γίνεται ένα loop στη λίστα με τις εντολές αλλά και τα αντίστοιχα arguments τους. Εαν ο αριθμός στο loop είναι μικρότερος από τις εντολές φτιάχνει pipes και στη συνέχεια κάνει fork. Το παιδί ορίζει κατάλληλα από που θα πάρει το input και που θα βγάλει το output ανάλογα σε πιο σημείο είναι στο pipe, αν έχει input από file και αν πρέπει να βγάλει το ouput στο stdout ή σε κάποιο outfile. Όλα αυτά γίνονται με τα κατάλληλα dup2 και close calls. Στη συνέχεια φτιάχνει τα arguments που θα περαστούν στην execvp και εκτελεί το exec. Έξω από το loop γίνεται ένα for το οποίο περιμένει τα παιδια με waitpid.

Background execution

Μία παραλλαγή αυτού που είπα είναι όταν το backgroundFlag είναι true, το οποίο σημαίνει ότι οι εντολές πρέπει να εκτελεστούν στο background. Αυτό φαίρνει 1 αλλαγές, η οποία είναι ότι μέσα στο παιδί η διεργασία μπαίνει σε ξεχωριστώ process group το οποίο μας δίνει τρεις δυνατότητες.

Τα σήματα ctrl+C kai ctrl+Z δεν σκοτώνουν ή κάνουν suspend όσες διεργασίες έχουν μπει στο background και τρέχουν ανεξάρτητα.
Μπορούμε να κάνουμε waitpid διεργασίες ενός group
Παρατήρησα ότι αν ένα background process πάει να διαβάσει από το τερματικό τη στιγμή εκτελείται μια foreground διεργασία, τότε το background process πολλές φορές διαβάζει από την είσοδο της foreground διεργασίας, κάτι που λύθηκε με τα process groups.
Επίσης να προσθέσω ότι πριν να γίνει το parse γίνεται ένα while loop με waitpid και option WNOHUNG, έτσι ώστε αν υπάρχει κάποια background εντολή που έχει τελειώσει να πάρουμε το status της και να μην γίνει ζόμπι.

History, aliases, wildcharacters, change directory και environment variables

Το ιστορικό είναι ένας δυναμικός πίνακας(Vector) ο οποίος αρχικοποιήται στην αρχή του προγράμματος και ενημερώνεται μετά από κάθε εντολή που διαβάζει το shell. Αν γράψουμε history ή myHistory τότε γίνεται print αυτός ο δυναμικός πίνακας και έτσι μπο- ρούμε να δούμε τις προηγούμενες εντολές. Μία αλλαγή που έκανα σε σχέση με τα ζητούμενα της άσκησης είναι να μην περιορίζω στο πόσες εντολές μπορώ να θυμάμαι (20 ήταν το ζητούμενο), αλλά χρησιμοποίησα δυναμικό πίνακα ο οποίος κάθε φορά που φτάνει στα όριά του διπλασιάζει τη χωρητικότητα επί δύο. Να προσθέσω επίσης, ότι αν γράψουμε μια εντολή και αυτή είναι ίδια με την τελευταία που είχαμε γράψει τότε δεν ξανακαταγράφεται στον δυναμικό πίνακα.

Εν συνεχεία υλοποίησα τη δυνατότητα myHistory n, αλλά με τη χρήση του θαυμαστικού (!n argument). Συγκεκριμένα υπάρχει δυνατό- τητα

!n το οποίο αναφέρεται στην n εντολή που υπάρχει στο history Vector
!-n το οποίο αναφέρεται στην εντολή n φορές πριν την τελευταία που έχουμε γράψει
!! το οποίο αναφέρεται στην προηγούμενη ακριβώς εντολή
!string το οποίο ψάχνει τον history vector για την εντολή η οποία αρχίζει με string και επιστρέφει την πιο πρόσφατη
Εννοείται ότι για τα προηγούμενα υπάρχει error handling σε περίπτωση που δεν υπάρχει event αλλά και η δυνατότητα να προσθέσουμε arguments δηλαδή αν η 2η εντολή που γράψαμε είναι ls μπορούμε να κάνουμε !2 modules και να εκτελεστεί το ls modules.

Όσο αφορά τα aliases, υλοποιούνται με ένα Map (hash table). Έτσι όταν έχουμε createalias myhome "/home/some/thing" τότε σαν key μπαίνει η συμβολοσειρά myhome και σαν value το "/home/some/thing". Το hash function που έχω υλοποιήσει είναι η djb2 συνάρτηση και την επέλεξα, διότι είναι απλή, γρήγορη και σε γενικές γραμμές αποδοτική. Εννοείται, ότι πριν από την εκτέ- λεση μιας εντολή πάντα τσεκάρετε το αν υπάρχει alias.

Όπως είπα και πιο πάνω, υπάρχει μία λίστα η οποία περιέχει τις λίστες με τα arguments κάθε εντολής. Αυτή η λίστα με λίστες κάθε φορά πριν εκτελεστούν οι εντολές με την execute_command, διατρέχεται και με τη βοήθεια της glob αντικαθιστώνται τυχόν wildcharacters.

Να αναφέρω ότι η λειτουργία του change directory έχει υλοποιηθεί πλήρως με τη βολήθεια της συνάρτησης chdir. Για την αντιμετώπιση των μεταβλητών περιβάλλοντος γίνεται το εξής. Στην αρχή του parsing, διατρέχεται όλη η εντολή μέχρι να αντικα- τασταθούν όλες οι environment variables. Για αυτή τη δουλειά έχω υλοποιήσει τη συνάρτηση replace_enc_vars.
